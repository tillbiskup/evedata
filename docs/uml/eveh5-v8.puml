@startuml
'https://plantuml.com/class-diagram

legend top left
    **eveH5 schema v8** <U+2014> not yet released, complete overhaul

    G: HDF5 groups; D: HDF5 datasets; <color:#firebrick><U+2610></color>: optional attributes
    Dataset columns appear below the attributes.
    Dataset names in angle brackets <> are replaced with actual names in an eveH5 file.
    'Name parts in square brackets [] are optional.
endlegend

class Root << (G,orchid) >> {
    EVEH5Version : string
    EVEVersion : string
    MeasurementStation : string
    {field} Start : string (YYYY-MM-DDThh:mm:ss)
    {field} End : string (YYYY-MM-DDThh:mm:ss)
    Description : string
    Comment : string
    Simulation : int | "boolean" enum
    - PreferredAxis : string
    - PreferredChannel : string
    - PreferredNormalizationChannel : string
}


Root *-- monitor
Root *-- main
Root *-- snapshot
Root *-- meta

enum DeviceType {
    SinglePointChannel
    AverageChannel
    IntervalChannel
    ArrayChannel
    AreaChannel
    Axis
    Device
    Option
}
note right of DeviceType
    This enum class may not be present
    in the actual HDF5 file, but it contains
    the controlled vocabulary for the
    DeviceType attribute of the datasets.

    This string gets used to map the datasets
    to the corresponding classes, and it
    corresponds to the overall data model.
endnote

enum DetectorType {
}
note left of DetectorType
    This enum class may not be present
    in the actual HDF5 file, but it contains
    the controlled vocabulary for the
    DetectorType attribute of the datasets.

    Valid entries need to be decided upon,
    but ideally they allow for sensible
    handling of the data in downstream
    packages.
endnote

class monitor << (G,orchid) >> <<optional>> {
}

monitor *-- "<monitordata>"

class main << (G,orchid) >> {}

class snapshot << (G,orchid) >> <<optional>> {}

note left of snapshot
    The ""snapshot"" group contains only datasets
    with scalar "values" per individual Position.
    "Data", however, can be 0D..2D per Position.
    This means that no average or interval channels
    will appear here, but perhaps array or area channels.
endnote

snapshot *-- "<axisdata>"
snapshot *-- "<singlepointdata>"
snapshot *.. "<arraydata>_sm<#>"
snapshot *.. "<areadata>_sm<#>"

class meta << (G,orchid) >> {}

meta *-- Positions2Milliseconds
meta *-- Scan
meta *-- Setup
meta *-- LogMessages

class "<axisdata>" << (D,orange) >> {
    PV : string
    AccessMode : string
    Name : string
    XMLID : string
    DeviceType : string
    - Unit : string
    --
    Positions : int32
    Data : float64
    RBV : float64 | vlen_float64
}

class "<singlepointdata>" << (D,orange) >> {
    PV : string
    AccessMode : string
    Name : string
    XMLID : string
    DeviceType : string
    DetectorType : string
    Unit : string
    - NormalizeID : string
    --
    Positions : int32
    Data : float64
    - NormalizedData : float64
    - NormalizingData : float64
}

main *-- "<axisdata>"
main *-- "<singlepointdata>"
main *-- "<averagedata>_sm<#>"
main *-- "<intervaldata>_sm<#>"
main *-- "<arraydata>_sm<#>"
main *-- "<areadata>_sm<#>"

class "<averagedata>_sm<#>" << (D,orange) >> {
    PV : string
    AccessMode : string
    Name : string
    XMLID : string
    DeviceType : string
    DetectorType : string
    Unit : string
    Averages : int32
    - NormalizeID : string
    - MaxAttempts : int32
    - MaxDeviation : float64
    - LowLimit : float64
    --
    Positions : int32
    Data : float64
    RawData : vlen_float64
    Preset : int32
    - Attempts : int32
    - NormalizedData : vlen_float64
    - NormalizingData : vlen_float64
}

class "<intervaldata>_sm<#>" << (D,orange) >> {
    PV : string
    AccessMode : string
    Name : string
    XMLID : string
    DeviceType : string
    DetectorType : string
    Unit : string
    - NormalizeID : string
    TriggerInterval : float64
    --
    Positions : int32
    Data : float64
    RawData : vlen_float64
    Count : int32
    StandardDeviation : float64
    - NormalizedData : vlen_float64
    - NormalizingData : vlen_float64
}

note as sm_channel_note
    All types of channels whose attributes can change
    for individual scan modules, are saved with the
    ""sm<#>"" prefix, where ""<#>"" denotes the scan module ID,
    <i>i.e.</i> a positive integer value.
    The "Name" attribute should have the same suffix.
end note

"<intervaldata>_sm<#>" .. sm_channel_note
"<averagedata>_sm<#>" .. sm_channel_note

class "<arraydata>_sm<#>" << (D,orange) >> {
    PV : string
    AccessMode : string
    Name : string
    XMLID : string
    DeviceType : string
    DetectorType : string
    Unit : string
    --
    Positions : int32
    Data : array
}

class "<areadata>_sm<#>" << (D,orange) >> {
    PV : string
    AccessMode : string
    Name : string
    XMLID : string
    DeviceType : string
    DetectorType : string
    Unit : string
    - FileType : string
    --
    Positions : int32
    Data : array | string
}

note bottom of "<areadata>_sm<#>"
    The "FileType" attribute will contain the relevant
    information on the file type of external files, in case
    the actual data are stored external to the HDF5 file.
    The string needs to be a controlled vocabulary understood
    by the importing routines and is set in the defining XML.
endnote

class Setup << (D,orange) >> {
    Version : string
    Filename : string
    --
    XML : string
}

class Scan << (D,orange) >> {
    Version : string
    Filename : string
    Author : string
    --
    XML : string
}

class Positions2Milliseconds << (D,orange) >> {
    Unit : string
    --
    Positions : int32
    Milliseconds : int32
}

class LogMessages << (D,orange) >> <<optional>> {
    --
    Timestamp : string
    Source : string
    Severity : string
    Message : vlen_string
}

note as SCML_note
    XML should be a fixed_length string and the dataset compressed,
    to save (a lot of) space.
    Tests have revealed compression by about 95% for real XML data.
    Not naming the data field results in proper display of the XML
    in HDFView, including line breaks, and regardless of compression.
end note

Scan .. SCML_note
Setup .. SCML_note

class "<monitordata>" << (D,orange) >> {
    PV : string
    AccessMode : string
    Name : string
    XMLID : string
    DeviceType : string
    - Unit : string
    --
    Milliseconds : int32
    Data : <i>any</i>
}

@enduml