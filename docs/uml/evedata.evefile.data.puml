@startuml
'skinparam dpi 150

class Data {
    metadata : Metadata
    options : dict
    _data : np.ndarray
    _importer : DataImporter
    data()
}
note left of Data::_data
    "_data" usually contains a 1D array and is accessed
    via the data() getter method (Python property) that
    calls the DataImporter on first access if necessary.

    For individual channel values see derived classes
    AverageChannelData and IntervalChannelData.

    ArrayChannelData and AreaChannelData are somewhat
    special as they contain either 2D data or a list of data objects
    (in case of images and alike).
end note

class DataImporter {
    source
    import()
}

class Metadata {
}
note left: See diagram for\nmetadata module.

Data *- DataImporter
Data *-- Metadata

class MeasureData extends Data {
    {field} positions : np.ndarray(dtype=int)
}

class MonitorData extends Data {
    {field} milliseconds : np.ndarray(dtype=int)
}

Metadata -[hidden]> MonitorData
MonitorData -[hidden]> MeasureData

class DeviceData extends MeasureData

class AxisData extends MeasureData {
    set_values
}

class NonencodedAxisData extends AxisData {
    _filled_data
    filled_data()
}
note bottom of NonencodedAxisData
    Data for axes without encoders are filled
    depending on the ChannelData they are
    plotted against.
    Hence for different channels, generally
    different filled data will exist.
endnote

class ChannelData extends MeasureData {
}

class TimestampData extends MeasureData {
    {field} _first_positions : np.ndarray(dtype=int)
    {field} _last_positions : np.ndarray(dtype=int)
    get_position(timestamp, mode=last)
}

class NonnumericChannelData extends ChannelData {}

'Help layout a bit
NonnumericChannelData -[hidden]> SinglePointChannelData
SinglePointChannelData -[hidden]> AverageChannelData
AverageChannelData -[hidden]> IntervalChannelData
IntervalChannelData -[hidden]> ArrayChannelData
ArrayChannelData -[hidden]> AreaChannelData

class SinglePointChannelData extends ChannelData {}

interface NormalizedData {
    normalized_data : np.ndarray
    normalizing_data : np.ndarray
}

class SinglePointNormalizedChannelData extends SinglePointChannelData implements NormalizedData {
}

class AverageChannelData extends ChannelData {
    raw_data : raggedarray
    {field} attempts : np.ndarray(dtype=int)
    _mean : np.ndarray
    _std : np.ndarray
    mean()
    std()
    averaged_data()
    has_raw_data()
}
note top of AverageChannelData
    averaged_values() returns only
    those values used to average over.

    How does mean() differ from data()?
    Probably, data() should return the
    averaged data - <i>i.e.</i>, mean().
end note

class AverageNormalizedChannelData extends AverageChannelData implements NormalizedData {
}


class IntervalChannelData extends ChannelData {
    raw_data : raggedarray
    {field} counts : np.ndarray(dtype=int)
    _mean : np.ndarray
    _std : np.ndarray
    mean()
    std()
    has_raw_data()
}

class IntervalNormalizedChannelData extends IntervalChannelData implements NormalizedData {
}

class ArrayChannelData extends ChannelData {
}

class MCAChannelData extends ArrayChannelData

class ScopeChannelData extends ArrayChannelData

class AreaChannelData extends ChannelData {
}

class SampleCameraData extends AreaChannelData

class ScientificCameraData extends AreaChannelData

note as array_area_channels_note
    For ""ArrayChannelData"" and ""AreaChannelData""
    see separate diagrams, as these classes are
    slightly more complex compositions.
end note

AreaChannelData .up. array_area_channels_note
ArrayChannelData .up. array_area_channels_note

@enduml
