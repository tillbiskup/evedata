@startuml
'skinparam dpi 150

class Data {
    metadata : Metadata
    _data : np.ndarray
    _importer : DataImporter
    data()
}
note left of Data::_data
    "_data" usually contains a 1D array and is accessed
    via the data() getter method (Python property) that
    calls the DataImporter on first access if necessary.

    For individual channel values see derived classes
    AverageChannelData and IntervalChannelData.

    ArrayChannelData and AreaChannelData are somewhat
    special as they contain either 2D data or a list of data objects
    (in case of images and alike).
end note

class DataImporter {
    source
    import()
}

class Metadata {
}
note right: See diagram for\nmetadata module.

Data *- DataImporter
Data *-- Metadata

class MeasureData extends Data {
    {field} positions : np.ndarray(dtype=int)
}

class MonitorData extends Data {
    {field} milliseconds : np.ndarray(dtype=int)
}

class DeviceData extends MeasureData

class AxisData extends MeasureData {
    set_values
    _filled_data
    filled_data()
}
note right of AxisData
    Data are filled depending on the
    ChannelData they are plotted against.
    Hence for different channels, generally
    different filled data will exist.
endnote

class EncoderAxisData extends AxisData {
    read_back_values
}

class ChannelData extends MeasureData {
}

class TimestampData extends MeasureData {
    {field} _first_positions : np.ndarray(dtype=int)
    {field} _last_positions : np.ndarray(dtype=int)
    get_position(timestamp, mode=last)
}

class SinglePointChannelData extends ChannelData {}

class SinglePointNormalizedChannelData extends SinglePointChannelData {
    normalized_data : np.ndarray
    normalizing_data : np.ndarray
}

class AverageChannelData extends ChannelData {
    raw_data : raggedarray
    {field} attempts : np.ndarray(dtype=int)
    _mean : np.ndarray
    _std : np.ndarray
    mean()
    std()
    averaged_data()
    has_raw_data()
}
note bottom of AverageChannelData
    averaged_values() returns only
    those values used to average over.

    How does mean() differ
    from values in Data?
end note

class AverageNormalizedChannelData extends AverageChannelData {
    normalized_data : raggedarray
    normalizing_data : raggedarray
}


class IntervalChannelData extends ChannelData {
    raw_data : raggedarray
    {field} counts : np.ndarray(dtype=int)
    _mean : np.ndarray
    _std : np.ndarray
    mean()
    std()
    has_raw_data()
}

class IntervalNormalizedChannelData extends IntervalChannelData {
    normalized_data : raggedarray
    normalizing_data : raggedarray
}

class ArrayChannelData extends ChannelData {
    roi[] : ArrayChannelROIData
}

ArrayChannelData *-- "0..n" ArrayChannelROIData

class ArrayChannelROIData {
    {field} label : string
    {field} marker : np.ndarray(dtype=int)
    {field} positions : np.ndarray(dtype=int)
    {field} data : np.ndarray()
}
note bottom of ArrayChannelROIData
    Should these ROI classes inherit from
    ChannelData? In this case, the attributes
    "positions" and "data" would not be necessary.

    Marker should be a two-element vector
    with positions on the x axis of the spectrum.
    Is "marker" the best name? Can we generalise
    to fit to AreaChannelROIData as well?

    What other attributes are relevant for
    Array Channel ROIs? What datasets exist
    in an eveH5 file?
endnote

class AreaChannelData extends ChannelData {
    roi[] : AreaChannelROIData
}

AreaChannelData *-- "0..n" AreaChannelROIData

class AreaChannelROIData {
}

@enduml
