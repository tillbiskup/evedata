@startuml
'skinparam dpi 150

class Data {
    metadata : Metadata
    options : dict
    importer[] : DataImporter
    _data : np.ndarray
    data()
    get_data()
}
note left of Data::_data
    "_data" usually contains a 1D array and is accessed
    via the data() getter method (Python property) that
    calls the DataImporter on first access if necessary.

    For individual channel values see derived classes
    AverageChannelData and IntervalChannelData.

    ArrayChannelData and AreaChannelData are somewhat
    special as they contain either 2D data or a list of data objects
    (in case of images and alike).
end note

class DataImporter {
    source : string
    load()
}

class HDF5DataImporter extends DataImporter {
    item : string
    mapping : dict
}

class ImageDataImporter extends DataImporter

note right of ImageDataImporter
    Needs to handle a list of image filenames,
    as per position one image needs to be loaded.
end note

HDF5DataImporter -[hidden]> ImageDataImporter

class Metadata {
}
note left: See diagram for\nmetadata module.

Data *- "n" DataImporter
Data *-- Metadata

class MeasureData extends Data {
    {field} positions : np.ndarray(dtype=int)
}

class MonitorData extends Data {
    {field} milliseconds : np.ndarray(dtype=int)
}

Metadata -[hidden]> MonitorData
MonitorData -[hidden]> MeasureData

class DeviceData extends MeasureData

class AxisData extends MeasureData {
    set_values : np.ndarray
}

class NonencodedAxisData extends AxisData {
    _filled_data : np.ndarray
    filled_data()
}
note bottom of NonencodedAxisData
    Data for axes without encoders are filled
    depending on the ChannelData they are
    plotted against.
    Hence for different channels, generally
    different filled data will exist.
endnote

class ChannelData extends MeasureData {
}

class TimestampData extends MeasureData {
    {field} _first_positions : np.ndarray(dtype=int)
    {field} _last_positions : np.ndarray(dtype=int)
    get_position(timestamp, mode=last)
}

class NonnumericChannelData extends ChannelData {}

'Help layout a bit
NonnumericChannelData -[hidden]> SinglePointChannelData
SinglePointChannelData -[hidden]> AverageChannelData
AverageChannelData -[hidden]> IntervalChannelData
IntervalChannelData -[hidden]> ArrayChannelData
ArrayChannelData -[hidden]> AreaChannelData

class SkipData extends ChannelData {}

class SinglePointChannelData extends ChannelData {}

interface NormalizedChannelData {
    normalized_data : np.ndarray
    normalizing_data : np.ndarray
}

class SinglePointNormalizedChannelData extends SinglePointChannelData implements NormalizedChannelData {
}

class AverageChannelData extends ChannelData {
    raw_data : raggedarray
    {field} attempts : np.ndarray(dtype=int)
    _mean : np.ndarray
    _std : np.ndarray
    mean()
    std()
    averaged_data()
    has_raw_data()
}
note top of AverageChannelData
    averaged_values() returns only
    those values used to average over.

    How does mean() differ from data()?
    Probably, data() should return the
    averaged data - <i>i.e.</i>, mean().
end note

class AverageNormalizedChannelData extends AverageChannelData implements NormalizedChannelData {
}


class IntervalChannelData extends ChannelData {
    raw_data : raggedarray
    {field} counts : np.ndarray(dtype=int)
    _mean : np.ndarray
    _std : np.ndarray
    mean()
    std()
    has_raw_data()
}

class IntervalNormalizedChannelData extends IntervalChannelData implements NormalizedChannelData {
}

class ArrayChannelData extends ChannelData {
}

class MCAChannelData extends ArrayChannelData

class ScopeChannelData extends ArrayChannelData

class AreaChannelData extends ChannelData {
}

class SampleCameraData extends AreaChannelData

class ScientificCameraData extends AreaChannelData

note as array_area_channels_note
    For ""ArrayChannelData"" and ""AreaChannelData""
    see separate diagrams, as these classes are
    slightly more complex compositions.
end note

AreaChannelData .up. array_area_channels_note
ArrayChannelData .up. array_area_channels_note

@enduml
